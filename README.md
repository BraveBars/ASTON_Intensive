# Вопросы и ответы:

### 1.	Назовите основные принципы ООП. Расскажите подробно о каждом.
1. **Инкапсуляция**: это процесс, который скрывает внутренние детали реализации объекта и предоставляет доступ к ним только через публичные методы. Это помогает защитить данные от случайного изменения и облегчает поддержку кода.
2. **Наследование**: позволяет создавать новый класс на основе существующего, наследуя его свойства и методы. Это способствует повторному использованию кода и упрощает его расширение.
3. **Полиморфизм**: это способность объектов разных классов обрабатывать одно и то же сообщение по-разному. Реализуется через переопределение методов и интерфейсы, позволяя использовать один интерфейс для разных типов данных.
4. **Абстракция**: это процесс выделения значимых характеристик объекта, игнорируя несущественные детали. В ООП это достигается с помощью абстрактных классов и интерфейсов.
### 2.	Расскажите про иерархию наследования. Подробно про методы класса Object.
Наследование в Java реализуется через **иерархию классов**:
<br/>Каждый класс в Java наследует от **класса Object**, который является корнем иерархии. Класс Object — вершина иерархии наследования. Все классы в Java неявно наследуются от Object. Обеспечивает базовые методы, такие как equals(), hashCode(), toString() и другие.
<br/>**Пользовательские классы** могут наследоваться от других классов, используя ключевое слово extends. Если класс не указывает явного родителя, он наследует от Object.
<br/>**Подклассы и суперклассы**. Класс, который наследует от другого класса, называется подклассом (или производным классом). Класс, от которого наследуют, называется суперклассом (или базовым классом).
<br/><br/>**Методы класса Object** включают:
1. **equals()**: сравнивает объекты на равенство. По умолчанию проверяет, ссылаются ли оба объекта на один и тот же экземпляр. Обычно переопределяется для сравнения содержимого объектов.
2. **hashCode()**: возвращает хэш-код объекта, который используется в коллекциях, таких как HashMap и HashSet. Если equals переопределен, то hashCode также должен быть переопределен, чтобы обеспечивать согласованность.
3. **toString()**: возвращает строковое представление объекта. По умолчанию возвращает строку, содержащую имя класса и хэш-код объекта. Обычно переопределяется для предоставления более информативного представления.
4. **getClass()**: возвращает объект Class, который представляет класс, к которому принадлежит данный объект. Этот метод может быть использован для получения информации о типе объекта во время выполнения.
5. **clone()**: создает копию объекта. Для использования этого метода класс должен реализовать интерфейс Cloneable, и метод clone() должен быть переопределен, чтобы обеспечить глубокое копирование (если необходимо).
6. **finalize()**: вызывается сборщиком мусора перед удалением объекта. Этот метод может использоваться для освобождения ресурсов. Однако его использование не рекомендуется, так как поведение сборщика мусора непредсказуемо.
7. **wait()**: приостанавливает выполнение текущего потока до тех пор, пока не будет вызван метод notify() или notifyAll() в том же объекте. Используется для межпоточного взаимодействия.
8. **notify()**: пробуждает один из потоков, которые ожидают на этом объекте (вызван метод wait()).
9. **notifyAll()**: пробуждает все потоки, которые ожидают на этом объекте.
### 3.	Что такое интерфейс, что такое абстрактный класс.
**Интерфейс**: это контракт, который определяет набор методов, которые класс должен реализовать. Интерфейсы не могут содержать реализации методов (до Java 8, после чего появились дефолтные методы).
<br/>**Абстрактный класс**: это класс, который не может быть инстанцирован и может содержать как абстрактные методы (без реализации), так и методы с реализацией. Он используется для создания базового класса с общими свойствами и поведением.
### 4.	Может ли интерфейс/абстрактный класс иметь конструктор, поля, статические/дефолтные методы.
Интерфейсы не могут иметь конструкторы и поля (только статические финальные переменные), но могут иметь статические и дефолтные методы.
Абстрактные классы могут иметь конструкторы, поля и статические методы.
### 5.	Что такое Enum, в чем отличие его от класса, может ли иметь методы, конструкторы, наследоваться и реализовывать интерфейсы.
Enum: это специальный класс для определения наборов констант. В отличие от обычных классов, enum не может наследоваться, но может реализовывать интерфейсы.
Enum может иметь методы и конструкторы, которые используются для инициализации значений.
### 6.	Расскажите про модификаторы доступа, к чему они применяются.
Модификаторы доступа определяют уровень доступа к классам и их членам:
<br/>**public**: доступен из любого места.
<br/>**protected**: доступен в пределах пакета и в подклассах.
<br/>**private**: доступен только внутри самого класса.
<br/>Указание без модификатора (**package-private**): доступен только в пределах одного пакета.
### 7.	Расскажите про конструкторы, с какими модификаторами они применяются, могут ли они наследоваться/переопределяться?
**Конструкторы** — это специальные методы, которые вызываются при создании объекта. Они могут быть: public, protected, private.
Конструкторы не наследуются, но могут быть переопределены в подклассах.
### 8.	Можно ли в классе заимплементировать 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?
Да, в классе можно заимплементировать два и более интерфейсов в языке программирования Java (и во многих других языках, поддерживающих интерфейсы). Если два интерфейса содержат метод с одинаковой сигнатурой (например, doSmth()), это не вызывает проблем. Класс, реализующий эти интерфейсы, обязан предоставить одну реализацию данного метода. Если в двух интерфейсах объявлен метод с одинаковым именем и сигнатурой (например, void doSmth();), то при реализации этих интерфейсов в классе достаточно реализовать этот метод один раз. Эта реализация будет использоваться для обоих интерфейсов. В данном примере метод doSmth из обоих интерфейсов разрешается в одну реализацию в классе MyClass. Это возможно, поскольку интерфейсы содержат только объявление метода, без реализации, и конфликтов не возникает.
А что если методы имеют разные дефолтные реализации (Java 8+)? С Java 8 интерфейсы могут содержать default-реализации методов. Если два интерфейса, которые класс реализует, имеют одинаковый метод с разными default-реализациями, возникает конфликт. В этом случае класс обязан переопределить метод и явно указать, как он должен работать. Если вы хотите использовать default-реализацию из одного из интерфейсов, это можно сделать с помощью ключевого слова super (InterfaceA.super.doSmth();).<br/>
**Вывод**: если оба интерфейса содержат метод с одинаковой сигнатурой, класс реализует его один раз, и эта реализация используется для обоих интерфейсов.
Если в интерфейсах есть разные default-реализации метода, класс обязан переопределить метод, чтобы устранить конфликт.
### 9.	Статический/динамический полиморфизм.
**Статический полиморфизм**: Реализуется через перегрузку методов на этапе компиляции (полиморфизм времени компиляции).<br/>
**Динамический полиморфизм** (с помощью абстракций): Реализуется через переопределение методов на этапе выполнения (полиморфизм времени выполнения ).
### 10.	Что является членами класса?
Членами класса являются поля (переменные экземпляра) и методы (функции), а также конструкторы и внутренние классы.
### 11.	Расскажите подробно как переопределяются/перегружаются методы классов наследников.
**Переопределение**: Изменяет реализацию метода в подклассе. Открывает возможность для динамического полиморфизма.<br/>
**Перегрузка**: Создает несколько методов с одинаковым именем, но с разными параметрами в одном классе.
### 12.	JVM, JRE, JDK.
**JVM (Java Virtual Machine)**: Исполняет Java-программы, управляет памятью и обеспечивает взаимодействие с операционной системой.<br/>
**JRE (Java Runtime Environment)**: Содержит JVM и стандартные библиотеки Java.<br/>
**JDK (Java Development Kit)**: Полный набор инструментов для разработки, включая JRE, компилятор и библиотеки.
### 13.	Расскажите что такое Classpath Java, общее правило именования пакетов java.
**Classpath**: Это параметр, указывающий, где Java ищет классы и ресурсы. Обычно включает директории и JAR-файлы.
**Именование пакетов**: Рекомендуется использовать доменное имя в обратном порядке, например, com.example.myapp.
### 14.	Расскажите про интерфейсы Comparator, Comparable и их применение.
**Comparable**: Позволяет объектам сравнивать себя с другими объектами одного типа. Используется для сортировки.
<br/>1) Определяет естественный порядок сортировки объектов.
<br/>2) Используется метод compareTo(), который сравнивает текущий объект (this) с другим объектом.
<br/>3) Класс, реализующий Comparable, обязан указать, как его объекты сравниваются друг с другом.
<br/>**Возвращает:** 0, если объекты равны; отрицательное число, если текущий объект "меньше" другого; положительное число, если текущий объект "больше" другого.
<br/>**Comparator**: Позволяет определять порядок сравнения между различными объектами. Может быть использован для кастомной сортировки.
<br/>1) Не требует изменения класса, объекты которого нужно сравнивать.
<br/>2) Используется метод compare(), который принимает два объекта и сравнивает их.
<br/>3) Можно создать несколько реализаций Comparator для разных критериев сортировки.
<br/>**Возвращает:** 0, если объекты равны; отрицательное число, если текущий объект "меньше" другого; положительное число, если текущий объект "больше" другого.
### 15.	Расскажите про класс String, пул строк.
**String**: Это неизменяемый класс для работы со строками.
<br/>**Пул строк**: Это область памяти, где хранятся строковые литералы. При создании строки, если такая строка уже существует в пуле, возвращается ссылка на существующий объект.
### 16.	Расскажите про варианты использования зарезервированных слов, таких как super, this, class, instance of.
**super**: Используется для доступа к родительским членам класса.
<br/>**this**: Ссылается на текущий объект.
<br/>**class**: Объявляет новый класс.
<br/>**instance of**: Проверяет, является ли объект экземпляром определенного класса или интерфейса.
### 17.	Java массивы, к какому типу относится, какие есть особенности, можно ли создать 0 длинны, могут ли расширяться.
Массивы являются объектами и имеют фиксированный размер после создания. Можно создать массив длиной 0.
Массивы не могут расширяться после создания.
### 18.	Назовите этапы создания/запуска блоков/конструкторов класса при наследовании.
При наследовании сначала выполняются статические блоки и инициализаторы родительского класса, затем конструкторы родительского класса, и только потом — дочернего.
### 19.	Расскажите какое будет поведение, если внутри цикла вызвать оператор break/continue?
**break**: прерывает выполнение цикла и выходит из него.
<br/>**continue**: пропускает текущую итерацию и переходит к следующей.
### 20.	Что такое Generics?
**Generics в Java** — это механизм обобщённого программирования, который позволяет создавать классы, интерфейсы и методы с параметризованным типом. Они обеспечивают:
<br/>1) **Безопасность типов**: предотвращают ошибки времени выполнения, связанные с преобразованием типов.
<br/>2) **Переиспользование кода**: один обобщённый класс/метод для разных типов данных.<br/>
Generics используют механизм **type erasure** (стирание типов) во время компиляции. Это означает, что информация о параметризованном типе удаляется, и в байт-коде используется базовый тип (Object или указанный ограничивающий тип).
### 21.	Расскажите про такое зарезервированное слово, как final, к чему оно применяется и как используется?
Ключевое слово final используется для создания неизменяемых сущностей. Оно применяется к:
<br/>1) **Классам**: Если класс объявлен как final, его нельзя наследовать.
<br/>2) **Методам**: Если метод объявлен как final, его нельзя переопределить в подклассе.
<br/>3) **Переменным**: Для примитивов: значение переменной нельзя изменить. Для ссылочных типов: нельзя изменить ссылку, но объект, на который она указывает, может быть изменён.
<br/>4) **Параметрам метода**: Параметры метода, объявленные как final, нельзя изменить внутри метода.
### 22.	Расскажите про Optional.
Optional — это специальный класс в Java, введённый в Java 8, который помогает избежать ошибок, связанных с использованием null. Это контейнер, который может содержать одно значение или быть пустым.
<br/>**Основные методы Optional:**
<br/> 1) Создание:
<br/>Optional.of(value) — создаёт Optional с непустым значением (если значение null, выбрасывается NullPointerException).
<br/>Optional.ofNullable(value) — создаёт Optional, который может быть пустым.
<br/>Optional.empty() — создаёт пустой Optional.
<br/>2) Проверка:
<br/>isPresent() — возвращает true, если значение присутствует.
<br/>ifPresent(Consumer) — выполняет действие, если значение присутствует.
<br/>3) Получение значения:
<br/>get() — возвращает значение (или выбрасывает исключение, если пусто).
<br/>orElse(value) — возвращает значение или заданное значение по умолчанию.
<br/>orElseGet(Supplier) — возвращает значение или вычисляет его через лямбда-выражение.
<br/>orElseThrow(Supplier) — выбрасывает исключение, если значение отсутствует.
### 23.	Что описывает и показывает Big O нотация? Как высчитывается, что фактически измеряется (привести примеры)?
Big O нотация — это способ выражения сложности алгоритма в зависимости от объёма данных (временной или пространственной). Она показывает, как изменяется время выполнения или потребление памяти при увеличении входных данных.
<br/>**Основные виды сложности:**
<br/>**O(1)** — Константная (не зависит от размера данных). Пример: доступ к элементу массива по индексу.
<br/>**O(log n)** — Логарифмическая. Пример: бинарный поиск.
<br/>**O(n)** — Линейная. Пример: одно прохождение массива.
<br/>**O(n log n)** — Логарифмически-линейная. Пример: быстрая сортировка.
<br/>**O(n²)** — Квадратичная. Пример: вложенные циклы.
<br/>**O(2ⁿ)** — Экспоненциальная. Пример: перебор всех возможных комбинаций.
### 24.	Основные алгоритмы сортировки (знать/понимать принцип работы).
**Пузырьковая сортировка (Bubble Sort)**: Сравнивает соседние элементы и меняет их местами. Сложность: O(n²). Память: O(1) (внутренняя сортировка).
<br/>**Сортировка выбором (Selection Sort)**: Находит минимальный элемент и помещает его на место. Сложность: O(n²). Память: O(1).
<br/>**Сортировка вставками (Insertion Sort)**: Вставляет элемент на своё место в отсортированной части массива. Сложность: O(n²). Память: O(1).
<br/>**Быстрая сортировка (Quick Sort)**: Выбирает опорный элемент (pivot) и делит массив на две части. Сложность: O(n log n) в среднем, O(n²) в худшем случае. Память: O(log n) (рекурсия).
<br/>**Сортировка слиянием (Merge Sort)**: Делит массив на части, сортирует их и сливает. Сложность: O(n log n). Память: O(n) (внешняя сортировка).
### 25.	Пузырьковая сортировка (сложность, память).
**Принцип работы**: сравнивает соседние элементы и меняет их местами, если они в неправильном порядке.
<br/>**Сложность**: Лучший случай: O(n) (массив уже отсортирован). Худший случай: O(n²).
<br/>**Память**: O(1) (не требует дополнительной памяти).
### 26.	Сортировка выбором (сложность, память).
**Принцип работы**: находит минимальный элемент в неотсортированной части массива и ставит его в начало.
<br/>**Сложность**: O(n²) (независимо от порядка элементов).
<br/>**Память**: O(1).
### 27.	Сортировка вставками (сложность, память).
**Принцип работы**: вставляет элементы на своё место в отсортированной части массива.
<br/>**Сложность**: Лучший случай: O(n). Худший случай: O(n²).
<br/>**Память**: O(1).
### 28.	Быстрая сортировка (сложность, память).
<br/>**Принцип работы**: выбирает опорный элемент, разделяет массив и рекурсивно сортирует части.
<br/>**Сложность**: Средний случай: O(n log n). Худший случай: O(n²).
<br/>**Память**: O(log n) (рекурсивная глубина).
### 29.	Сортировка слиянием (сложность, память).
**Принцип работы**: делит массив на части, сортирует их рекурсивно и сливает.
<br/>**Сложность**: O(n log n).
<br/>**Память**: O(n).
### 30.	Жадный алгоритм.
**Жадный алгоритм** — это стратегия принятия решений, где на каждом шаге выбирается локально оптимальное решение с надеждой, что оно приведет к глобально оптимальному результату. Жадные алгоритмы не всегда гарантируют оптимальное решение, но часто работают быстро и применимы для ряда задач.
<br/>**Примеры задач, решаемых жадным алгоритмом:**
<br/>Задача о размене монет (если номиналы монет составляют жадную систему, например, 1, 5, 10, 25).
<br/>Задача о покрытии отрезков минимальным числом точек.
<br/>Задача о рюкзаке (дробный рюкзак, а не целочисленный).
<br/>**Важные особенности:** Жадные алгоритмы работают эффективно, если задача удовлетворяет свойствам оптимальности подструктуры и жадного выбора. Если задача не удовлетворяет этим свойствам, жадный алгоритм может дать не оптимальное решение.
### 31.	Бинарный поиск.
Бинарный поиск используется для поиска элемента в отсортированном массиве. Принцип работы основан на делении массива на две части и исключении той, в которой элемент не может находиться.
<br/>**Алгоритм работы:** Проверить средний элемент массива: если он равен искомому, поиск завершён; если меньше искомого, продолжить поиск в правой половине; если больше искомого, продолжить поиск в левой половине. Повторять процесс до нахождения элемента или до того, как массив станет пустым.
<br/>**Сложность:** Временная: O(log n). Пространственная: O(1).
### 32.	Алгоритмы поиска пути: обход в глубину, обход в ширину.
**Обход в глубину (DFS - Depth First Search)**: Исследует граф (или дерево), начиная с корневой вершины, углубляясь как можно дальше вдоль каждого пути, прежде чем возвращаться назад. Реализуется с использованием рекурсии или стека.
<br/>**Обход в ширину (BFS - Breadth First Search)**: Исследует вершины графа уровня за уровнем. Реализуется с использованием очереди.<br/>
![image](https://github.com/user-attachments/assets/6dda44c6-1110-4252-a1a2-6fadbd99dcc7)
### 33.	Какие структуры данных вы знаете?
1) **Линейные структуры данных**: Массивы. Связанные списки (однонаправленные, двунаправленные). Стек. Очередь (обычная очередь, двусторонняя очередь, приоритетная очередь).
<br/>2) **Деревья**: Бинарное дерево. Двоичное дерево поиска (BST). AVL-дерево. Красно-чёрное дерево. B-дерево.
<br/>3) **Графы**: Ориентированные/неориентированные графы. Взвешенные графы.
<br/>4) **Хэш-таблицы (HashTable, HashMap).**
<br/>5) **Множества (Set)**: HashSet. TreeSet.
<br/>6) **Другие**: Дека (Deque). Trie (префиксное дерево).
### 34.	Массивы: достоинства и недостатки.
**Достоинства**: Быстрый доступ к элементу по индексу (O(1)). Простота реализации.
<br/>**Недостатки**: Фиксированный размер. Высокая стоимость операций вставки/удаления (O(n) в худшем случае).
### 35.	Связанные списки: достоинства и недостатки, временная сложность добавления/поиска/удаления элемента.
**Достоинства**: Динамический размер. Быстрая вставка/удаление (O(1), если известна позиция).
<br/>**Недостатки**: Медленный поиск (O(n)). Дополнительная память на хранение указателей.
<br/>**Сложности**: 
<br/>1) **Добавление**: O(1) (если в начало/конец).
<br/>2) **Поиск**: O(n).
<br/>3) **Удаление**: O(1) (если известен узел).
### 36.	Стек: достоинства, недостатки, временная сложность добавления/поиска/удаления элемента.
**Стек (Stack)** — структура данных, работающая по принципу LIFO (последний вошел — первый вышел).
<br/>**Достоинства:** Простота реализации. Используется для рекурсии, алгоритмов поиска, обработки выражений (например, обратная польская нотация).
<br/>**Недостатки:** Ограничение по доступу к элементам (можно работать только с вершиной). Неэффективен для хранения больших объемов данных.
<br/>**Временная сложность:** Добавление: O(1) (операция push). Поиск: O(n) (если требуется доступ к элементу, который не на вершине). Удаление: O(1) (операция pop).
### 37.	Очередь: достоинства, недостатки, временная сложность добавления/поиска/удаления элемента.
**Очередь (Queue)** — структура данных, работающая по принципу FIFO (первый вошел — первый вышел).
<br/>**Достоинства:** Хорошо подходит для задач планирования, обработки потоков данных. Простота реализации.
<br/>**Недостатки:** Ограничение доступа (работа только с началом и концом очереди). Для эффективной реализации требуется кольцевая очередь или список.
<br/>**Временная сложность:** Добавление: O(1). Поиск: O(n) (если требуется доступ к произвольному элементу). Удаление: O(1).
### 38.	Деревья: достоинства, недостатки, временная сложность, добавления/поиска/удаления элемента.
**Дерево** — иерархическая структура данных, состоящая из узлов. Каждый узел имеет родителя (кроме корня) и может иметь несколько потомков.
<br/>**Достоинства:** Быстрый поиск, вставка и удаление (в сбалансированных деревьях). Представление иерархических данных (файловая система, дерево решений).
<br/>**Недостатки:** Требует больше памяти (для указателей на дочерние узлы). Неэффективен в несбалансированном состоянии (например, в случае линейного дерева).
<br/>**Временная сложность (для сбалансированного дерева)**: Добавление: O(log n). Поиск: O(log n). Удаление: O(log n).
### 39.	На какие основные группы можно поделить типы данных?
**1) Примитивные типы данных (Primitive types):** byte, short, int, long, float, double, char, boolean.
<br/>**2) Ссылочные типы данных (Reference types):** классы, интерфейсы, массивы, перечисления (Enum).
### 40.	Какие примитивные типы вы знаете?
**1) Целочисленные типы:** byte (1 байт), short (2 байта), int (4 байта), long (8 байт).
<br/>**2) С плавающей точкой:** float (4 байта), double (8 байт).
<br/>**3) Символьный:** char (2 байта, Unicode).
<br/>**4) Логический:** boolean (1 бит, значения true/false).
### 41.	Что вы знаете о преобразовании примитивных типов данных (есть ли потеря данных, можно ли преобразовать логический тип)?
1) **Неявное (widening):** Меньший тип преобразуется в больший (например, int → long). int a = 10; long b = a; // Неявное преобразование
<br/>2) **Явное (narrowing):** Больший тип преобразуется в меньший (может быть потеря данных). double d = 10.5; int a = (int) d; // Округление, результат: 10
<br/>**Потеря данных:** При преобразовании большего типа в меньший (например, long → int) или при округлении дробных чисел (double → int).
<br/>Логический тип (boolean) нельзя преобразовать в числовой и наоборот.
### 42.	Какими значениями инициализируются переменные по умолчанию?
**Примитивы:** byte, short, int, long → 0. float, double → 0.0. char → \u0000 (нулевой символ Unicode). boolean → false.
<br/>**Ссылочные типы:** null.
### 43.	Как передается значение переменной (по ссылке/значению)?
В Java все данные передаются по значению: для примитивных типов передаётся значение, а для ссылочных типов передаётся копия ссылки, но не сам объект.
### 44.	Что вы знаете про классы-обёртки?
**Классы-обёртки (Wrapper classes)** используются для представления примитивных типов как объектов. Примеры: Integer, Double, Boolean, Character и т. д.
<br/>**Особенности:** Поддерживают методы для работы с примитивами. Используются в Generics (т. к. Generics работают только с объектами). Автоматическое преобразование (autoboxing/unboxing): Integer a = 10; // autoboxing; int b = a; // unboxing
### 45.	Определение коллекции.
**Коллекция (Collection)** — это структура данных для хранения группы объектов (элементов). В Java коллекции представлены через интерфейсы и их реализации в java.util.
### 46.	Преимущества использования коллекций.
1) Динамическое управление размером (в отличие от массивов).
<br/>2) Универсальный доступ к элементам.
<br/>3) Удобные методы для сортировки, поиска, фильтрации.
<br/>4) Богатая иерархия классов и интерфейсов.
### 47.	Какие объекты можно хранить в коллекциях?
Можно хранить любой объект (включая пользовательские классы). Примитивы хранятся через обёртки (Integer, Double и т. д.).
### 48.	Иерархия коллекций.
Иерархия коллекций в Java представлена интерфейсами и классами в пакете java.util. Она организована в виде структуры, где базовым интерфейсом является Collection, а также отдельным корнем для ассоциативных коллекций выступает интерфейс Map (он не является частью Collection).
<br/>**Основные интерфейсы:**
<br/>1) **Коллекции (Collection):**
<br/>List (упорядоченные коллекции с возможностью дублирования элементов): ArrayList, LinkedList.
<br/>Set (коллекция, которая не допускает дублирования элементов (уникальные элементы)): HashSet, LinkedHashSet, TreeSet (по умолчанию – естественный порядок или с использованием Comparator).
<br/>Queue (очередь — коллекция, работающая по принципу "первый вошел – первый вышел" (FIFO)): LinkedList (реализует Queue), PriorityQueue.
<br/>Deque (двунаправленная очередь с возможностью добавления/удаления элементов на обоих концах): ArrayDeque, LinkedList (также реализует Deque).
<br/>2) **Ассоциативные коллекции (Map) (пары "ключ-значение": ключи уникальны, значения могут повторяться)**: HashMap, LinkedHashMap, ConcurrentHashMap, TreeMap.
### 49.	Отличия Vector от ArrayList.
**Vector**: Устаревший, синхронизирован. Медленнее из-за синхронизации.
<br/>**ArrayList**: Не синхронизирован. Быстрее при работе в одном потоке.
### 50.	Что знаете о коллекциях типа List (как добавляется элемент\расширяется коллекция)?
**List** — упорядоченная коллекция, допускает дубликаты. Интерфейс List является частью пакета java.util и поддерживает работу с элементами по индексам, что делает его похожим на массив, но с динамическим управлением размером. При добавлении элементов размер коллекции изменяется автоматически.
<br/>**Основные реализации List:**
<br/>1) ArrayList (массив, который имеет фиксированный размер). При добавлении элемента: Если есть свободное место в массиве, элемент добавляется в конец. Если массив заполнен, создается новый массив большего размера (по умолчанию увеличивается на 50%) и все элементы копируются в новый массив. Элемент добавляется в новый массив. Динамически расширяется, если массив переполнен. По умолчанию начальная емкость ArrayList равна 10 (если вы не укажете другую емкость). При переполнении емкость увеличивается примерно на 50% (проверяется, есть ли свободное место в массиве. Если места нет, создается новый массив размером oldCapacity * 1.5. Элементы копируются из старого массива в новый). Используйте, если требуется быстрый доступ по индексу. Подходит для часто читаемых данных с редкими операциями вставки/удаления.
<br/>2) LinkedList (двусвязный список). При добавлении элемента: Если добавление происходит в конец, создается новая нода, которая становится последним элементом.
Если добавление происходит в определенный индекс, создается новая нода, ссылки соседних нод обновляются для включения новой ноды. LinkedList не требует выделения массива и не использует фиксированный размер. Он расширяется динамически, добавляя новые ноды при необходимости. Каждая новая нода выделяется в памяти отдельно и не зависит от размера предыдущих. Используйте, если требуется частое добавление/удаление в начале/середине списка. Подходит для данных с большим количеством вставок/удалений.
### 51.	Что знаете о коллекциях типа Set?
**Set** — это интерфейс коллекций в Java, который представляет множество уникальных элементов (не допускает дубликатов). Он является частью пакета java.util и расширяет интерфейс Collection. Коллекции типа Set используются, когда важна уникальность элементов, а порядок хранения элементов может быть не важен (в зависимости от реализации). Допускаются null значения (один null) (в зависимости от реализации). Основные реализации: HashSet (порядок не гарантируется, быстрая): O(1) для операций добавления/удаления. LinkedHashSet: порядок вставки сохраняется, допускаются null значения (один null). TreeSet (отсортированная, элементы упорядочены по естественному порядку (или с использованием компаратора), реализован на основе красно-черного дерева, не позволяет хранить null значения (вызывает NullPointerException)): O(log n).
### 52.	Что знаете о коллекциях типа Queue?
**Queue** — интерфейс, который наследуется от интерфейса Collection. Очереди предназначены для хранения элементов в порядке их добавления, что обеспечивает доступ к элементам по принципу "первый пришел - первый вышел" (FIFO — First In, First Out).
<br/>**Основные характеристики интерфейса Queue:**
<br/>1) Позволяет добавлять элементы в конец очереди и удалять их с начала.
<br/>2) Может иметь фиксированный или динамический размер.
<br/>3) Может поддерживать разные условия и правила для обработки (например, приоритетные очереди).
<br/>**Основные реализации:** LinkedList (FIFO) (реализует интерфейс Queue и Deque. Хранит элементы в виде двусвязного списка, что позволяет эффективно добавлять и удалять элементы), ArrayDeque (реализует интерфейс Deque и может работать как очередь, хранит элементы в массиве, обеспечивая хорошую производительность по сравнению с LinkedList в большинстве случаев), PriorityQueue (в порядке приоритета) (реализует Queue и хранит элементы в соответствии с их приоритетом. Элементы могут быть упорядочены с помощью естественного порядка или заданного компаратора), BlockingQueue (подинтерфейс Queue, который позволяет использовать очереди в многопоточных средах. Предоставляет методы для безопасного добавления и удаления элементов, блокируя потоки при необходимости. Примеры реализации: ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue).
### 53.	Что знаете о коллекциях типа Map и их принципиальное отличие?
**Map** — представляет собой коллекцию, которая хранит данные в виде пар "ключ-значение". Каждому ключу соответствует одно значение, и ключи должны быть уникальными. Коллекции типа Map являются частью Java Collections Framework и используются для хранения данных, доступ к которым осуществляется по ключу. Принципиальное отличие: Map не является наследником Collection.
<br/>**Основные характеристики интерфейса Map:**
<br/>1) Хранение пар "ключ-значение": каждый элемент в Map состоит из ключа и соответствующего ему значения.
<br/>2) Уникальные ключи: каждый ключ может присутствовать только один раз; если при добавлении нового значения для уже существующего ключа будет использоваться тот же ключ, предыдущее значение будет заменено.
<br/>3) Операции доступа: предоставляет методы для добавления, удаления и получения значений по ключу.
<br/>**Основные реализации Map:**
<br/>1) **HashMap** (использует хеш-таблицу для хранения данных, позволяет быстрый доступ к элементам (в среднем O(1) по времени) по ключу, но не гарантирует порядок элементов (порядок может изменяться)).
<br/>2) **LinkedHashMap** (расширяет HashMap, сохраняя порядок вставки элементов, что позволяет итерацию по элементам в порядке их добавления; позволяет сохранить порядок, но с небольшими потерями в производительности по сравнению с HashMap).
<br/>3) **TreeMap** (реализует интерфейс SortedMap и поддерживает порядок по ключам, используя красно-черную структуру дерева; позволяет доступ к элементам в отсортированном порядке по ключам).
<br/>4) **Hashtable** (подобно HashMap, но является синхронизированной (потокобезопасной) коллекцией; поддерживает только null в качестве значения, но не в качестве ключа.
<br/>**Принципиальное отличие между коллекциями типа Map и другими коллекциями (например, List и Set)**.
<br/>**Структура данных:** List и Set хранят отдельные объекты, тогда как Map хранит пары ключей и значений.
<br/>**Доступ по ключу:** в Map данные можно быстро искать и получать по ключу, в то время как в List и Set — это достигается по индексу или с помощью итератора.
<br/>**Уникальность ключей:** в Map ключи уникальны, хотя значения могут повторяться (в Set все элементы уникальны, а в List могут быть дубликаты).
### 54.	Назовите основные реализации List, Set, Map.
**List**:
<br/>1) **ArrayList** (Использует динамический массив для хранения элементов. Быстрый доступ по индексу (O(1)), но медленные операции вставки и удаления (O(n)), если они происходят не в конце списка. Позволяет дублирование элементов);
<br/>2) **LinkedList** (Реализует двусвязный список. Обеспечивает более быстрые операции вставки и удаления по сравнению с ArrayList (O(1)), особенно для операций в начале и середине списка. Имеет немного более высокий расход памяти);
<br/>**Set**:
<br/>1) **HashSet** (Основная реализация интерфейса Set. Хранит элементы в хеш-таблице и не гарантирует порядок. Быстрый доступ и проверка наличия элемента (O(1)));
<br/>2) **LinkedHashSet** (Наследует от HashSet и сохраняет порядок вставки элементов. Обеспечивает более предсказуемый порядок и также обеспечивает быструю доступность (O(1)));
<br/>3) **TreeSet** (Реализует интерфейс SortedSet. Хранит элементы в отсортированном порядке, используя красно-черное дерево. Обеспечивает медленный доступ (O(log n)) по сравнению с HashSet, но упрощает операции поиска, добавления и удаления);
<br/>**Map**:
<br/>1) **HashMap** (Использует хеш-таблицу для хранения пар "ключ-значение". Не гарантирует порядок элементов. Быстрый доступ по ключу (O(1)));
<br/>2) **LinkedHashMap** (Наследует от HashMap и сохраняет порядок вставки пар "ключ-значение". Обеспечивает эффект кэширования, что делает его полезным для простановки порядка при итерации);
<br/>3) **TreeMap** (Реализует интерфейс SortedMap. Хранит пары "ключ-значение" в отсортированном порядке, автоматически сортируя ключи).
### 55.	Что общего у ArrayList\LinkedList, когда какой лучше использовать?
**Общие свойства**: 
<br/>(Оба реализуют интерфейс List, соответственно имеют пул общих методов: add(), remove(), size() и т.д.);
<br/>**Отличия**: 
<br/>1) **get()** (Так как ArrayList под капотом хранит данные в массиве, ArrayList имеет гораздо более быстрый доступ к данным по индексу O(1), в отличии от LinkedList O(n));
<br/>2) **set()** (Присваивание элемента по индексу в ArrayList быстрее по тем же причинам);
<br/>3) **add(i, val)** (Добавление элемента в любую точку массива у LinkedList занимает O(1), у ArrayList только в конец O(1), добавление в начало или середину занимает O(n));
<br/>4) **remove()** (Удаление элементов аналогично добавлению у LinkedList всегда O(1), у ArrayList O(n) или же O(1) при удалении последнего элемента;
<br/>**Вывод:** если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае - ArrayList
### 56.	Расскажите про HashSet.
Класс **HashSet** реализует интерфейс Set, основан на хэш-таблице, а также поддерживается с помощью экземпляра HashMap. В HashSet элементы не упорядочены, нет никаких гарантий, что элементы будут в том же порядке спустя какое-то время. Может хранить только уникальные значения, может хранить NULL – значения, порядок добавления элементов вычисляется с помощью хэш-кода.
<br/>**Особенности**
<br/>1) Выгода от хеширования состоит в том, что оно обеспечивает постоянство времени выполнения операций add(), contains(), remove() и size(), даже для больших наборов.
<br/>2) Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования сам по себе обычно не приводит к созданию отсортированных множеств.
<br/>3) Фактически под капотом HashSet - находится HashMap, а сама структура HashSet - это набор ключей HashMap.
### 57.	Расскажите про TreeSet/как сортируются элементы.
Класс TreeSet реализует интерфейс NavigableSet, который поддерживает элементы в отсортированном по возрастанию порядке. Объекты сохраняются в отсортированном порядке по возрастанию. Класс TreeSet<E> для хранения объектов использует бинарное красно-черное дерево. При добавлении объекта в дерево он сразу же размещается в необходимую позицию с учетом сортировки. Сортировка происходит благодаря тому, что все добавляемые элементы реализуют интерфейсы Comparator и Comparable. Обработка операций удаления и вставки объектов происходит медленнее, чем в хэш-множествах, но быстрее, чем в списках – O(logn).
<br/>**Правила красно-черного дерева**
<br/>1) Узел может быть либо красным, либо черным и имеет двух потомков;
<br/>2) Корень — как правило черный (Как правило - потому что, если мы говорим о поддеревьях - это не всегда так);
<br/>3) Все листья, не содержащие данных — черные;
<br/>4) Оба потомка каждого красного узла — черные;
<br/>5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов.
<br/> _Простой путь – это тот, в котором каждый узел входит ровно по одному разу._
### 58.	Как задается порядок следования объектов в коллекции, как отсортировать коллекцию.
<br/>1) Нужно выбрать коллекцию, которая поддерживает сортировку: TreeSet, TreeMap, List.
<br/>2) Коллекции на основе дерева (TreeSet, TreeMap) сортируются автоматически. Для коллекции List нужно вызвать метод list.sort().
<br/>3) Должна быть возможность сравнивать элементы в коллекции между собой.
<br/>----- если сами объекты реализуют интерфейс Comparable, то они сравниваются методом a.compareTo(b)
<br/>----- либо можно передать в коллекцию объект Comparator, определяющий правила сортировки. В TreeSet и TreeMap компаратор передается в конструкторе, в List - при вызове метода sort().
### 59.	Iterator. Как его получить(). Его методы: что и зачем?
Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс **Iterator**.
<br/>Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().
### 60.	Iterable - что за зверь? Что за контракт описывает.
<br/>Интерфейс **Iterable** предоставляет более удобный способ работы с коллекциями, позволяя использовать цикл for-each для итерации по элементам коллекции. Именно он содержит метод iterator(), который возвращает уже знакомый нам объект Iterator. Также интерфейс содержит методы forEach() и spliterator(). Они уже имеют реализацию по умолчанию, поэтому каждый раз их реализовывать не нужно.
<br/>Иногда возникает необходимость при обходе коллекции через forEach() тут же её модифицировать. Чаще всего требуется удаление элементов, если они удовлетворяют определённым условиям. Первое, что приходит в голову, это сделать удаление прямо внутри цикла for-each. Если мы попробуем выполнить это таким способом, то получим исключение ConcurrentModificationException при попытке удаления элемента. Дело в том, что внутри итератора стоит проверка, не изменилось ли количество элементов во время обхода коллекции? И если изменилось, то возникает такое исключение.
<br/>**ИНФОРМАЦИИ ПО ПОВОДУ КОНТРАКТОВ Я НЕ НАШЁЛ**
### 61.	Коллекция 10 элементов.Вызываю 9x Iterator.hasNext а затем Iterator.next. Что вернется.
Вернется первый элемент коллекции и итератор сдвинется ко второму элементу, так как hasNext() просто проверяет, есть ли следующий элемент, но не перемещает итератор вперед.
### 62.	Как перебрать все ключи значения Map (можно ли через Iterable)?
Можно перебрать все ключи и значения **Map** разными способами, но Map сам по себе не реализует **Iterable**, поэтому его нельзя напрямую использовать в for-each. Однако можно работать с его представлениями (keySet(), values(), entrySet()), которые реализуют Iterable.
<br/>В различных ситуациях можно использовать такие способы перебора, в зависимости от конкретной цели:
<br/>1)    entrySet() + for-each	Оптимальный способ: удобный и быстрый
<br/>2)    keySet() + get()	Когда нужны только ключи (get() выполняется отдельно, что может быть менее эффективным в некоторых реализациях Map)
<br/>3)    values()	Когда нужны только значения
<br/>4)    Iterator	Когда нужно удалять элементы во время итерации
<br/>5)    forEach()	Краткий код (начиная с Java 8, нельзя удалять элементы)
<br/>6)    Stream API	Для сложных операций (фильтрация, маппинг и т. д.)
### 63.	Разница Iterator, Enumerator, ListIterator.
Основная разница заключается в том, что **Iterator** используется в	Коллекции (List, Set, Map.entrySet(), и т. д.), **Enumerator**	в старых классах (Vector, Hashtable), **ListIterator** только в List (например, ArrayList, LinkedList). Другие различия:
<br/>1)    ListIterator может совершать обход, как вперед, так и назад (остальные только вперед).
<br/>2)    ListIterator может изменять элементы (set(), add())
<br/>3)    Enumerator не может удалять элементы.
<br/>4)    Enumerator может работать с устаревшими файлами (не fail-fast), остальные выбросят ConcurrentModificationException при изменении коллекции.
<br/>В целом Enumerator устарел и был заменен Iterator, ListIterator же является аналогом Iterator для работы с List.
### 64.	В каких случаях может быть выброшено ConcurrentModificationException?
Иногда возникает необходимость при обходе коллекции через forEach() тут же её модифицировать. Чаще всего требуется удаление элементов, если они удовлетворяют определённым условиям. Первое, что приходит в голову, это сделать удаление прямо внутри цикла for-each. Если мы попробуем выполнить это таким способом, то получим исключение ConcurrentModificationException при попытке удаления элемента. Дело в том, что внутри итератора стоит проверка, не изменилось ли количество элементов во время обхода коллекции? И если изменилось, то возникает такое исключение.
### 65. Что такое Stream API?
Stream API — это набор инструментов в Java, введённый в версии 8, который позволяет работать с последовательностями элементов, например, коллекциями (List, Set, и т. д.), с использованием функционального стиля программирования. Это позволяет удобно и эффективно обрабатывать данные с помощью потоков, поддерживая операции вроде фильтрации, сортировки и трансформации, без явных циклов и изменений состояния.
### 66. Каковы основные преимущества использования Stream API?
**StreamAPI** имеет ряд приемуществ:
<br/>**Удобство и читаемость:** Функциональный стиль программирования Stream API позволяет писать код, используя более декларативный стиль. Это упрощает понимание логики работы, поскольку операции над потоками легко читаемы и выражаются в виде цепочек операций.
<br/>**Ленивые вычисления:** Stream API использует ленивую оценку операций. Это означает, что элементы обрабатываются только тогда, когда это необходимо (например, при сборе или выводе результатов). Это помогает избежать лишней работы.
<br/>**Параллельная обработка:** Масштабируемость и производительность: Потоки можно обрабатывать параллельно, что позволяет эффективно использовать многозадачность и многозадачные вычисления. Это может значительно улучшить производительность при работе с большими данными.
<br/>**Отсутствие изменения исходных данных:** Потоки не изменяют исходные коллекции или данные, с которыми они работают. Это помогает избегать побочных эффектов, обеспечивая безопасность и предсказуемость.
<br/>**Уменьшение количества кода:** Менее громоздкий код Stream API позволяет выполнять сложные операции с коллекциями (например, фильтрацию, сортировку, агрегацию) без явного использования циклов. Это упрощает код и снижает вероятность ошибок.
<br/>**Поддержка работы с большими данными:** Часто используемые паттерны: Stream API идеально подходит для обработки данных в реальном времени, работы с большими коллекциями, например, в случаях потоковой обработки (stream processing).
<br/>**Универсальность:** Потоки могут быть использованы с различными источниками данных, такими как коллекции, массивы, файлы, и даже данные из сетевых потоков, что делает API гибким и универсальным для различных задач.
### 67. Какие основные операции доступны в Stream API?
В Stream API есть два типа операций: промежуточные (intermediate) и терминальные (terminal). Промежуточные операции выполняются в цепочке, а терминальные операции завершают процесс обработки потока и возвращают результат. Промежуточные операции возвращают новый поток и не изменяют исходный, эти операции являются ленивыми (lazy), т.е. они не выполняются, пока не будет вызвана терминальная операция. Терминальные операции производят окончательные вычисления или возвращают результат, завершив обработку потока. После вызова терминальной операции поток считается "исчерпанным".
<br/>**Промежуточные операции**
<br/>1)    filter(Predicate<? super T> predicate): Фильтрует элементы потока, оставляя только те, которые соответствуют условию.
<br/>2)    map(Function<? super T, ? extends R> mapper): Преобразует элементы потока, применяя функцию ко всем элементам.
<br/>3)    flatMap(Function<? super T, ? extends Stream<? extends R>> mapper): Преобразует элементы потока в несколько потоков и объединяет их в один поток.
<br/>4)    distinct(): Убирает дубликаты из потока.
<br/>5)    sorted(): Сортирует элементы потока в порядке возрастания.
<br/>6)    peek(Consumer<? super T> action): Операция, которая позволяет выполнить действие над каждым элементом потока, не изменяя его. Обычно используется для отладки.
<br/>7)    limit(long maxSize): Ограничивает количество элементов в потоке.
<br/>8)    skip(long n): Пропускает первые n элементов потока.
<br/>**Терминальные операции**
<br/>1)    collect(Collector<? super T, A, R> collector): Собирает элементы потока в коллекцию или другой контейнер. Это одна из самых популярных операций.
<br/>2)    forEach(Consumer<? super T> action): Применяет действие к каждому элементу потока.
<br/>3)    reduce(T identity, BinaryOperator<T> accumulator): Выполняет агрегирование элементов потока. Применяет бинарную операцию ко всем элементам потока и возвращает одно значение.
<br/>4)    anyMatch(Predicate<? super T> predicate): Проверяет, удовлетворяет ли хотя бы один элемент условию.
<br/>5)    allMatch(Predicate<? super T> predicate): Проверяет, удовлетворяют ли все элементы потока условию.
<br/>6)    noneMatch(Predicate<? super T> predicate): Проверяет, удовлетворяет ли ни один элемент потока условию.
<br/>7)    findFirst(): Возвращает первый элемент потока (если он существует).
<br/>8)    findAny(): Возвращает произвольный элемент потока. Может быть использовано в параллельных потоках.
<br/>9)    count(): Возвращает количество элементов в потоке.
<br/>10)    max(Comparator<? super T> comparator): Возвращает максимальный элемент потока, согласно заданному компаратору.
<br/>11)    min(Comparator<? super T> comparator): Возвращает минимальный элемент потока.
### 68. Как можно объединять несколько Stream с помощью Stream API?
Для объединения нескольких потоков в **Stream API** есть несколько удобных методов:
<br/>1)    Stream.concat() — для объединения двух потоков.
<br/>2)    flatMap() — для более сложных случаев, когда каждый элемент потока сам является потоком.
<br/>3)    Stream.of() — для создания потока из других потоков.
<br/>4)    Использование коллекций и терминальных операций, таких как collect(), для сбора элементов.
### 69. Как использовать Stream API для обработки ошибок?
В Stream API обработки ошибок в явном виде нет, так как потоки сами по себе не обрабатывают исключения. Однако, можно интегрировать обработку ошибок в процессе работы с потоками с помощью различных способов:
<br/>Обработка исключений с использованием **try-catch внутри лямбда-выражений** для обработки ошибок на каждом шаге потока. Это позволяет перехватывать исключения и контролировать, что происходит в случае ошибки.
<br/>Использование **Optional** для безопасного обработки значений. Если методы, которые используются в потоке, могут вернуть null или выбросить исключение, можно использовать Optional. Это позволяет безопасно работать с возможными ошибками, не выбрасывая исключения. Стоит отметить, что этот способ включает в себя и использование try-catch
<br/>Применение **пользовательских исключений** в потоке.
<br/>Использование **peek()** для отладки и логирования ошибок. Метод peek() позволяет выполнять дополнительные действия с каждым элементом потока (например, логировать или отлаживать), не изменяя сам поток. Это может быть полезно для логирования ошибок полученных при использовании try-catch.
<br/>Использование **пользовательского обработчика исключений**. Если нужно централизованно обрабатывать ошибки в потоке, можно создать отдельную функцию для обработки исключений и использовать её в map() или других операциях.
### 70. Как использовать методы фильтрации в Stream API, что принимает/возвращает?
Метод **filter()** используется для того, чтобы отфильтровать элементы потока, оставив только те, которые удовлетворяют условию, заданному через лямбда-выражение или метод, реализующий интерфейс Predicate. Принимает: Predicate<? super T> — это функциональный интерфейс, который определяет условие фильтрации (логика, по которой будет решаться, оставлять или исключать элемент). Возвращает: новый поток, содержащий только те элементы, которые прошли фильтрацию (удовлетворяют условию).
<br/>Метод **distinct()** используется для удаления дубликатов в потоке. Он сохраняет только уникальные элементы. Принимает: ничего — он работает по умолчанию с уникальными значениями. Возвращает: новый поток, содержащий только уникальные элементы исходного потока.
<br/>Метод **limit()** ограничивает количество элементов в потоке до заданного числа. Принимает: long maxSize — максимальное количество элементов, которые должны быть возвращены. Возвращает: новый поток, содержащий не более maxSize элементов из исходного потока.
<br/>Метод **skip()** пропускает первые n элементов потока и возвращает оставшиеся элементы. Принимает: long n — количество элементов, которые нужно пропустить. Возвращает: новый поток, который начинается с элемента после первых n элементов исходного потока.
<br/>Метод **takeWhile()** доступен начиная с Java 9. Он фильтрует элементы потока, принимая элементы, пока условие в predicate возвращает true. Как только условие становится ложным, оставшиеся элементы пропускаются. Принимает: Predicate<? super T> — условие, по которому элементы будут отбираться. Возвращает: новый поток, содержащий элементы, удовлетворяющие условию до того момента, как условие перестанет выполняться.
<br/>Метод dropWhile() также появился в Java 9 и фильтрует элементы потока, пропуская их до тех пор, пока условие не перестанет быть истинным. Принимает: Predicate<? super T> — условие, по которому элементы будут пропускаться. Возвращает: новый поток, пропускающий элементы, удовлетворяющие условию, и начиная с того момента, когда условие становится ложным, возвращает оставшиеся элементы.
### 71. Как применять Collectors.groupingBy() Stream API, что принимает/возвращает?
Метод Collectors.groupingBy() используется в Stream API для группировки элементов потока на основе заданного критерия. Он позволяет создавать группы элементов, сгруппированных по ключу, который задается с помощью функции. Этот метод полезен, когда необходимо объединить элементы в группы и выполнить агрегацию по этим группам.
<br/>**Принимает:** Function<? super T, ? extends K> classifier — функцию, которая определяет, как сгруппировать элементы потока. Она преобразует каждый элемент потока в ключ для группы. Collector<? super T, A, D> downstream — (необязательный параметр) позволяет выполнить дополнительную агрегацию внутри каждой группы. Это может быть, например, подсчет элементов в группе, создание списка и т.д.
<br/>**Возвращает:** Map<K, List<T>>, где K — это тип ключа, а List<T> — список элементов, сгруппированных по этому ключу.
### 72. Как можно использовать Stream API для преобразования одного типа данных в другой, например, int[] {1,2,3}?
Методы **Stream API** предоставляют различные способы преобразования типов данных, включая:
<br/>1)    map() — для преобразования элементов потока.
<br/>2)    mapToObj() — для преобразования примитивных типов в объекты.
<br/>3)    boxed() — для преобразования примитивных типов в соответствующие обертки (например, из int в Integer).
<br/>4)    toArray() — для преобразования потока в массив.
<br/>5)    Агрегирование — с использованием таких методов, как sum(), count(), average(), и т. д.
<br/>Эти возможности позволяют гибко работать с потоками данных и трансформировать их в нужные типы.
### 73. Отличия flatMap от Map?
**map()**: Преобразует один элемент в один новый элемент. Если нужно преобразовать элементы, то результатом будет поток с теми же количеством элементов, но преобразованных.
<br/>**flatMap()**: Возвращает поток (или коллекцию) для каждого элемента. Потоки этих коллекций затем объединяются в один поток, что может привести к увеличению количества элементов.
<br/>**flatMap()** полезен при работе с вложенными структурами, тогда как **map()** подходит для простых преобразований элементов.
### 74. Как работать с параллельными потоками с помощью Stream API?
Можно использовать **parallel()** для создания параллельного потокаю. Этот метод можно вызывать на любом потоке, и он автоматически делит работу на несколько потоков.
<br/>Использование **parallelStream()** для создания параллельного потока. Если у необходимо обработать коллекцию (например, List, Set), можно использовать метод parallelStream(), который сразу создает параллельный поток.
### 75. Как использовать метод forEach в Stream API? - что принимает/возвращает?
Метод **forEach()** в Stream API используется для того, чтобы выполнить действие для каждого элемента потока. Это терминальная операция, то есть после ее выполнения поток считается завершенным, и дальнейшая работа с ним невозможна.
<br/>**Что принимает:** Метод forEach() принимает обработчик (представленный интерфейсом Consumer<T>), который выполняется для каждого элемента потока.
<br/>**Что возвращает:** Метод forEach() ничего не возвращает (его возвращаемое значение — void).
### 76. Как использовать метод peek в Stream API? - что принимает/возвращает?
Метод **peek()** в Stream API используется для просмотра или отладки элементов потока во время его обработки. Этот метод позволяет выполнять действия с элементами потока, не изменяя самих элементов. Он полезен, когда нужно просто "посмотреть", что происходит с элементами потока в промежуточных стадиях обработки. Это промежуточная операция, которая не изменяет сам поток, но позволяет выполнить побочные эффекты для каждого элемента потока (например, для логирования или отладки).
<br/>**Что принимает:** Метод peek() принимает Consumer<T> — функциональный интерфейс, который описывает операцию, выполняемую над каждым элементом потока.
<br/>**Что возвращает:** Метод peek() возвращает сам поток (тип Stream<T>), что позволяет использовать его в цепочке операций.
### 77. Как работает метод reduce в Stream API? - что принимает/возвращает? Варианты и методы.
Метод **reduce()** в Stream API используется для накопления элементов потока в одно значение. Это терминальная операция, которая позволяет выполнить редукцию (сведение) элементов потока к результату через последовательное применение функции-аккумулятора.
<br/>**Что принимает:** Метод reduce() принимает два варианта аргументов: BinaryOperator<T> — операция для объединения двух элементов потока. T identity и BinaryOperator<T> — начальное значение и операция для объединения двух элементов.
<br/>**Что возвращает:** Вариант с двумя аргументами: возвращает Optional<T>, так как в потоке может быть 0 или более элементов. Вариант с тремя аргументами: возвращает T, начальное значение.
### 78. Как создать бесконечный поток с помощью Stream API?
В Stream API можно создать бесконечный поток с помощью методов **Stream.iterate()** и **Stream.generate()**. Эти методы позволяют создавать потоки, которые не имеют конечного размера и могут работать бесконечно.
<br/>Метод **iterate()** позволяет создать бесконечный поток, начиная с начального значения и применяя функцию для получения следующего элемента.
<br/>Метод **generate()** создает бесконечный поток, используя Supplier<T>, который генерирует элементы по мере необходимости.
### 79. Какие ограничения есть у Stream API?
Основные **ограничения Stream API**:
<br/>Потоки в Stream API **могут быть использованы только один раз**. После того как поток был использован (например, через методы forEach(), collect(), reduce() и т. д.), его нельзя повторно использовать.
<br/>Потоки **должны быть не изменяемыми**. Операции над потоком не должны изменять состояние исходных коллекций. Поток не должен модифицировать объекты или коллекции, через которые он проходит, так как это может вызвать неожиданные результаты, особенно в параллельных потоках.
<br/>Использование параллельных потоков (parallelStream()) может быть сложным и **не всегда эффективно**. Для параллельных потоков важно, чтобы операции были ассоциативными и идемпотентными (то есть не зависели от порядка выполнения). Например, операции, которые изменяют состояние объектов или коллекций (например, forEach() с побочными эффектами), могут нарушить корректность работы параллельных потоков.
<br/>Все промежуточные операции в Stream API (например, map(), filter()) **не изменяют сами данные в коллекции**. Вместо этого они создают новые потоки, что означает, что данные нельзя модифицировать "на месте" в потоке.
<br/>В Stream API желательно избегать использования **операций с побочными эффектами**. Это особенно важно в контексте параллельных потоков. Например, использование peek() для изменения состояния внешних объектов может привести к ошибкам, особенно при параллельной обработке данных. Потоки должны быть функциональными и не менять внешнее состояние, чтобы гарантировать корректную работу операций.
<br/>Ограничения по **работе с состоянием** (строгие ограничения). Потоки не могут зависеть от изменяющихся внешних состояний. Это значит, что поток должен работать с неизменяемыми данными. Например, операции map() или filter() не должны изменять состояния объектов, так как это может нарушить правильность результатов.
<br/>Потоки, особенно бесконечные потоки (например, через Stream.iterate() или Stream.generate()), могут привести к **утечкам памяти или перегрузке памяти**, если не заданы ограничения (например, через limit()).
<br/>Потоки **не поддерживают произвольный доступ к элементам**, так как они базируются на концепции ленивых вычислений. Это означает, что элементы обрабатываются последовательно и в том порядке, в котором они поступают, а доступ по индексу невозможен (в отличие от коллекций).
<br/>Потоки **не поддерживают типичные коллекционные операции**, такие как add(), remove() или clear(), поскольку они ориентированы на операции для обработки данных, а не для изменения состояния коллекций.
<br/>В случае параллельных потоков операции могут выполняться в непредсказуемом порядке. Если важно **сохранить порядок** элементов (например, при использовании forEach() или collect()), следует избегать параллельных потоков или использовать операции, которые явно сохраняют порядок.
### 80. Как передать переменную в стрим что с ней можно сделать?
В Stream API в Java можно передавать переменные в поток **с помощью лямбда-выражений или ссылок на методы**.
<br/> Переменные, определенные в методе, могут быть использованы внутри лямбда-выражений, если они не изменяются внутри лямбда-выражений.
### 81. Как создать Optional?
### 82. Отличие Optional of() от Nullable().
### 83. В чем отличие методов ifPresent и orElse в контексте Optional?
### 84. Каким образом можно объединить два Optional в один, используя метод join?
### 85. Что проверяет ifPresent Optional?
### 86. Каким образом можно преобразовать Stream в массив или коллекцию?
### 87. В чём отличие методов orElseGet и orElse?
### 88. Каким образом можно реализовать обработку ошибок с использованием Optional и метод orElseThrow?
### 89. Какова иерархия исключений?
![image](https://github.com/user-attachments/assets/2a1bc6a5-178c-4d05-9644-78cf7ab44278)
### 90. Дайте определение понятию “исключение”.
Исключение – это событие, возникающее при выполнении программы, которое прерывает нормальный поток её работы и требует специальной обработки (try-catch, throws).
### 91. Какая конструкция используется в Java для обработки исключений?
Обработка исключений в Java основана на использовании в программе следующих ключевых слов:
<br/><b>try</b> – определяет блок кода, в котором может произойти исключение;
<br/><b>catch</b> – определяет блок кода, в котором происходит обработка исключения;
<br/><b>finally</b> – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока try.
```java
try {
    // код, который может выбросить исключение
} catch (ExceptionType e) {
    // обработка исключения
} finally {
    // код, который выполняется в любом случае
}
```
### 92. Можно/нужно ли обрабатывать ошибки JVM?
Можно, но ошибки типа Error (например, OutOfMemoryError) обычно не обрабатываются, поскольку свидетельствуют о критических системных проблемах.
Программистам рекомендуется обрабатывать исключения, но не ошибки JVM.
### 93. Какие существуют способы обработки исключений?
<br/>Локально: через блоки try-catch и finally.
<br/>Декларативно: через объявление throws в сигнатуре метода.
<br/>Глобально: с использованием обработчиков (например, Thread.setDefaultUncaughtExceptionHandler).
<br/>Дополнительные способы обработки исключений:
<br/>try-with-resources
<br/>Это специальная форма блока try, которая автоматически закрывает ресурсы (например, файлы или соединения), реализующие интерфейс AutoCloseable, после завершения работы.
<br/>Пользовательские исключения
<br/>Можно создавать свои собственные классы исключений, наследуя их от Exception (для checked исключений) или RuntimeException (для unchecked исключений), и обрабатывать их так же, как стандартные.
### 94. О чем говорит ключевое слово throws?
Указывает, что метод может выбросить исключение, которое должен обработать вызывающий код.
### 95. В чем особенность блока finally? Всегда ли он исполняется?
Блок finally выполняется всегда после блока try (и catch), независимо от того, произошло исключение или нет. 
Он используется для освобождения ресурсов (например, закрытия потоков, соединений) и выполняется даже если был выполнен return в try или catch.
### 96. Когда блок finally не будет выполнен?
Вызове System.exit() до входа в блок finally.
Катастрофической ошибке, приводящей к немедленному завершению работы JVM.
### 97. Может ли не быть ни одного блока catch?
Можно использовать конструкцию try-finally без блока catch, если требуется выполнить финализирующий код независимо от возникновения исключения.
### 98. Что вы знаете об (checked/unchecked) исключениях?
<b>Checked exceptions:</b> Исключения, которые проверяются компилятором (например, IOException). Методы, которые их выбрасывают, обязаны объявлять их в throws.<br/>
<br/><b>Unchecked exceptions:</b> Подклассы RuntimeException – не требуют обязательной обработки, так как обычно сигнализируют об ошибках программирования.
### 99. Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований порядок блоков исключений)?
Начиная с Java 7, один блок catch может перехватывать несколько исключений (с использованием синтаксиса multi-catch):
```java
try {
    // возможный код выброса исключения
} catch (IOException | SQLException ex) {
    // обработка
}
```
### 100. Особенность RuntimeException.
public class RuntimeException extends Exception — базовый класс для ошибок во время выполнения. Особенность класса RuntimeException в том, что этот класс наследуется от класса Exception, но является подклассом непроверяемых исключений, то есть не требует обработки или объявления с помощью оператора throws. Это сделано для того, чтобы программисты могли легче обрабатывать ошибки, связанные с некорректным использованием методов класса, например, когда указывается неправильный индекс массива или деление на ноль. RuntimeException могут возникать в ходе выполнения программы, и обычно их нельзя заранее предотвратить. Единственное, что можно сделать, - это обработать исключение, если оно возникнет.
### 101. Как выбрать свой: checked/unchecked?
**Checked exceptions:** должны быть обработаны в блоке cath или объявлены в сигнатуре метода. Используются для ситуаций, которые могут возникнуть, но не являются результатом ошибок программирования (например, IOException).
<br>**Unchecked exceptions:** не требуют обязательной обработки. Используются для ошибок программирования (например, NullPointerException). Выбор зависит от того, хотите ли вы, чтобы пользователи Вашего кода обрабатывали исключения или нет.
Все исключительные ситуации делятся на «проверяемые» (checked) и «непроверяемые» (unchecked) (смотрите картинку в начале статьи). Это свойство присуще «корневищу» (Throwable, Error, Exception, RuntimeException) и передается по наследству. Никак не видимо в исходном коде класса исключения.
В дальнейших примерах просто учтите, что— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked
checked exception = проверяемое исключение, проверяемое компилятором.
Тема достаточно обширная для того, чтобы уместить ее в одном ответе. К примеру, можно разобрать примеры Головача: http://habrahabr.ru/company/golovachcourses/blog/225585/
И еще с quizful.net
1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception (не включая unchecked).
Checked исключения отличаются от Unchecked исключения в Java, тем что:
1)Наличие\обработка Checked исключения проверяются на этапе компиляции. Наличие\обработка Unchecked исключения происходит на этапе выполнения.
### 102.Какой оператор позволяет принудительно выбросить исключение?
В Java для принудительного выброса исключения используется оператор throw. Он позволяет бросить объект-исключение, указанный после ключевого слова throw, в текущем методе или блоке кода.
Вот пример, который демонстрирует использование оператора throw для выброса исключения:
```java
public class Main {
    public static void main(String[] args) {
        try {
            int a = 10;
            int b = 0;
            if (b == 0) {
                throw new ArithmeticException("Деление на ноль недопустимо");
            }
            int result = a / b;
            System.out.println(result);
        } catch (ArithmeticException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```
В этом примере мы проверяем делитель на равенство нулю и, если он равен нулю, бросаем исключение типа ArithmeticException с сообщением "Деление на ноль недопустимо". Затем мы ловим это исключение в блоке catch и выводим соответствующее сообщение.
Примерный вывод:
Ошибка: Деление на ноль недопустимо
### 103. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?
Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.
public void someMethod() throws Exception {
}
### 104. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).
### 105. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?
Вернется из блока finally.
    public static void main(String[] args) {
       String what =  method();
        System.out.println(what);
    }
     public static String method() {
        try {
            return "SomeString";
        } catch(Exception ex) {
            return "Catch message";
        } finally {
            return "Finally message";
        }
    }
//Вывод
Finally message
### 106. Что вы знаете о OutOfMemoryError, SQLException? К какому типу checked или unchecked оно относится, почему?
OutOfMemoryError выбрасывается, когда виртуальная машина Java не может выделить (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить ещё.
Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места.
Области памяти
1. java.lang.OutOfMemoryError: Java heap space
   Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые программно в вашем приложении. Размер задается параметрами -Xms и -Xmx. Если вы пытаетесь создать объект, а места в куче не осталось, то получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество, и интернет просто пестрит статьями на эту тему.
2. java.lang.OutOfMemoryError: PermGen space
   Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.
3. java.lang.OutOfMemoryError: GC overhead limit exceeded
   Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и GC постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать, а либо решать проблему утечки памяти, либо выделять больше объема, либо менять настройки GC.
4. java.lang.OutOfMemoryError: unable to create new native thread
Выбрасывается, когда нет возможности создать еще потоки.
SQLException — это класс исключений в языке программирования Java, представляющий ошибки, возникающие при доступе к базе данных с помощью JDBC. SQLException — это проверенное исключение, что означает, что оно должно быть либо перехвачено, либо объявлено в сигнатуре метода с помощью ключевого слова «throws». Непроверенные исключения, такие как RuntimeException и Error, могут быть выброшены без объявления в сигнатуре метода.
Причина, по которой SQLException является проверенным исключением, заключается в том, что оно представляет собой исправимую ошибку при доступе к базе данных, и код, использующий JDBC, должен иметь возможность осмысленно обрабатывать эти ошибки. Например, исключение SQLException может быть выдано, если не удается установить соединение с базой данных или если запрос не выполняется из-за синтаксической ошибки.
Делая SQLException проверенным исключением, язык Java гарантирует, что разработчики знают об этих возможных состояниях ошибок и вынуждены обрабатывать их в своем коде. Следовательно, чтобы использовать JDBC в Java, вы должны либо обрабатывать SQLException с помощью блок try-catch или объявите его, используя ключевое слово «throws» в сигнатуре метода.
OutOfMemoryError — это ошибка, которая указывает на нехватку памяти. Это Error, а не Exception, и относится к unchecked.
SQLException — это checked exception, которая возникает при работе с базами данных, и требует обработки.
### 107. Error? В каком случае используется Error (пример Error’а).
Error — это класс в Java, представляющий ошибку времени выполнения или ошибку, связанную с приложением, которую нельзя исправить. Исключение Error возникает, когда возникает серьезная проблема, от которой программа не должна пытаться восстановиться. Примеры ситуаций, которые могут привести к ошибке, включают исчерпание ресурсов на уровне системы, отсутствие системных файлов и переполнение стека. Вот пример того, как выдать ошибку в Java:
if (someCondition) {
throw new Error("This is an example of an Error");
}
В этом примере выдается ошибка с сообщением «Это пример ошибки», если условие истинно. Программа не должна пытаться исправить эту ошибку, а вместо этого должна завершить работу или предпринять другие соответствующие действия.
### 108. Как хэш SHA-1 используется в Git?
Git использует SHA-1 для создания уникальных идентификаторов для объектов (коммитов, деревьев и т.д.). Каждый объект в Git имеет свой хэш, который вычисляется на основе содержимого объекта, что обеспечивает целостность данных.
### 109. Каковы основные состояния файла в Git?
Три состояния
Теперь слушайте внимательно. Это самая важная вещь, которую нужно запомнить о Git, если вы хотите, чтобы остаток процесса обучения прошёл гладко. У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован (staged) и зафиксирован (committed):
К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
Индексированный - это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
Зафиксированный значит, что файл уже сохранён в вашей локальной базе.
Мы подошли к трём основным секциям проекта Git: рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory).
Рабочая копия, область индексирования и каталог Git
Рисунок 6. Рабочая копия, область индексирования и каталог Git
Рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.
Область индексирования - это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.
Каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.
Базовый подход в работе с Git выглядит так:
Изменяете файлы вашей рабочей копии.
Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в индекс.
Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.
Если определённая версия файла есть в каталоге Git, эта версия считается зафиксированной (committed). Если файл был изменён и добавлен в индекс, значит, он индексирован (staged). И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается изменённым (modified). В главе Основы Git вы узнаете больше об этих состояниях и какую пользу вы можете извлечь из них или как полностью пропустить часть с индексом.
### 110. Команды git init, что создается? Как скопировать удаленный репозиторий?
git init создает новый пустой репозиторий Git в текущем каталоге.
Для копирования удаленного репозитория используется команда git clone <url>.
### 111. Что происходит после создания коммита?
После создания коммита изменения фиксируются в истории репозитория, и указатель HEAD перемещается на новый коммит.
### 112. Как добавить комит и зафиксировать его?
Добавьте изменения в индекс: git add <file>.
Зафиксируйте изменения: git commit -m "Your commit message".
### 113. Нужно ли отправлять коммиты на сервер для завершения рабочего процесса Git?
Не обязательно. Коммиты сохраняются локально, но для совместной работы и резервного копирования рекомендуется отправлять их на удаленный сервер с помощью git push.
### 114. Что происходит при git fetch?
git fetch загружает изменения из удаленного репозитория, но не сливает их с Вашей локальной веткой.
### 115. Что происходит при git merge?
git merge объединяет изменения из одной ветки в другую. Это может привести к конфликтам, если изменения не могут быть автоматически объединены.
### 116. Разрешает ли Git конфликты автоматически?
Git пытается разрешить конфликты автоматически, но если это невозможно, пользователю нужно будет вручную разрешить конфликты.
### 117. Возможен ли git pull, если в файле в рабочем каталоге есть незафиксированные изменения?
Нет, если есть незафиксированные изменения, git pull может вызвать конфликт. Лучше сначала зафиксировать изменения.
### 118. Что за команда git cherry-pick (можно ли добавить несколько комитов)?
git cherry-pick позволяет применить изменения из одного или нескольких коммитов в текущую ветку. Можно указать несколько коммитов, например:
git cherry-pick commit1 commit2
### 119. Какова цель указателя HEAD?
HEAD указывает на текущую ветку или коммит, на котором Вы находитесь. Это позволяет Git знать, какие изменения Вы собираетесь вносить.
### 120. В каких случаях возникает конфликт?
Конфликт возникает, когда изменения в одной ветке не могут быть автоматически объединены с изменениями в другой ветке.
### 121. Как изменить историю коммитов (rebase amend)?
git commit --amend позволяет изменить последний коммит.
git rebase позволяет переписать историю коммитов, перемещая их на другую базу.
### 122. В чем разница между git merge и git rebase? О чем следует помнить при изменении истории веток?
git merge создает новый коммит слияния, сохраняя историю обеих веток.
git rebase перемещает коммиты на новую базу, что делает историю более линейной. Следует помнить, что rebase изменяет историю, что может вызвать проблемы при работе с общими ветками.
### 123. Как разрешать конфликты?
Конфликты разрешаются вручную, редактируя конфликтующие файлы, а затем выполняя git add и git commit.
### 124. Что такое git remote и git clone?
git remote — это ссылка на удаленный репозиторий.
git clone создает локальную копию удаленного репозитория.
### 125. Что такое detached HEAD?
Detached HEAD — это состояние, когда HEAD указывает на конкретный коммит, а не на ветку. Это может произойти, если Вы проверяете конкретный коммит.
### 126. Варианты reset?
git reset --soft <commit>: перемещает HEAD, оставляя изменения в индексе.
git reset --mixed <commit>: перемещает HEAD и сбрасывает индекс, но сохраняет изменения в рабочем каталоге.
git reset --hard <commit>: перемещает HEAD и сбрасывает все изменения в рабочем каталоге.
### 127. Что такое git revert?
git revert создает новый коммит, который отменяет изменения, внесенные предыдущим коммитом. Это безопасный способ отмены изменений.
### 128. Как снести удаленно ветку, которую запушил?
Для удаления удаленной ветки используйте команду:
git push origin --delete <branch-name>
